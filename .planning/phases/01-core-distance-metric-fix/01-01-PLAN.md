---
phase: 01-core-distance-metric-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/eink-dither/src/palette/palette.rs
  - crates/eink-dither/src/dither/blue_noise.rs
  - src/rendering/svg_to_png.rs
  - CHANGES.md
autonomous: true

must_haves:
  truths:
    - "A grey gradient (0-255) on BWRGBY palette produces only black and white palette indices"
    - "Pure red, green, blue, and yellow pixels each match their exact palette entry"
    - "Orange (off-palette chromatic) maps to a chromatic palette entry, not to black or white"
    - "All existing crate tests pass (195 pass, 0 fail)"
  artifacts:
    - path: "crates/eink-dither/src/palette/palette.rs"
      provides: "HyAB + chroma coupling distance metric, precomputed actual_chroma"
      contains: "kchroma"
    - path: "crates/eink-dither/src/dither/blue_noise.rs"
      provides: "Updated find_second_nearest with chroma-aware distance"
      contains: "pixel_chroma"
    - path: "src/rendering/svg_to_png.rs"
      provides: "Caller updated with kchroma: 2.0"
      contains: "kchroma: 2.0"
  key_links:
    - from: "crates/eink-dither/src/palette/palette.rs"
      to: "DistanceMetric::HyAB"
      via: "kchroma field added to enum variant"
      pattern: "kchroma:\\s*f32"
    - from: "crates/eink-dither/src/palette/palette.rs::distance()"
      to: "actual_chroma Vec<f32>"
      via: "chroma coupling penalty term in HyAB branch"
      pattern: "kchroma\\s*\\*"
    - from: "crates/eink-dither/src/palette/palette.rs::find_nearest()"
      to: "distance()"
      via: "passes pixel_chroma computed once before loop"
      pattern: "pixel_chroma"
    - from: "crates/eink-dither/src/dither/blue_noise.rs::find_second_nearest()"
      to: "palette.distance()"
      via: "passes pixel_chroma and palette index"
      pattern: "pixel_chroma"
    - from: "src/rendering/svg_to_png.rs::build_eink_palette()"
      to: "DistanceMetric::HyAB"
      via: "adds kchroma: 2.0 to constructor"
      pattern: "kchroma:\\s*2\\.0"
---

<objective>
Add chroma coupling penalty to the HyAB distance metric so that grey pixels map to achromatic palette entries and chromatic pixels map to correct chromatic entries on multi-color e-ink palettes.

Purpose: Fix the root cause of color bleed in dithered output -- grey gradients currently produce colored pixels because standard HyAB alone does not penalize chroma magnitude differences in discrete palette matching.

Output: Working chroma-coupled HyAB metric with tests proving correct behavior on BWRGBY palette.
</objective>

<execution_context>
@/Users/oetiker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/oetiker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-distance-metric-fix/01-RESEARCH.md
@crates/eink-dither/src/palette/palette.rs
@crates/eink-dither/src/dither/blue_noise.rs
@src/rendering/svg_to_png.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add kchroma to HyAB and update all distance calculations</name>
  <files>
    crates/eink-dither/src/palette/palette.rs
    crates/eink-dither/src/dither/blue_noise.rs
    src/rendering/svg_to_png.rs
  </files>
  <action>
Modify `palette.rs` -- the core implementation:

1. **DistanceMetric enum** (line ~38): Add `kchroma: f32` field to the `HyAB` variant. Update the doc comment to describe the chroma coupling penalty formula: `kl * |dL| + kc * sqrt(da^2 + db^2) + kchroma * |C_pixel - C_palette|`. Remove the outdated recommendation to use `kc: 10.0` for forcing greys to achromatic.

2. **Palette struct** (line ~87): Add field `actual_chroma: Vec<f32>` after `actual_oklab`. This stores precomputed chroma magnitudes for each actual palette entry.

3. **Palette::new()** (after line ~180 where `actual_oklab` is computed): Compute `actual_chroma`:
   ```rust
   let actual_chroma: Vec<f32> = actual_oklab
       .iter()
       .map(|c| (c.a * c.a + c.b * c.b).sqrt())
       .collect();
   ```
   Add `actual_chroma` to the `Ok(Self { ... })` return struct.

4. **Palette::distance()** (line ~292): Change signature to accept pixel chroma and palette index:
   ```rust
   pub fn distance(&self, a: Oklab, b: Oklab, pixel_chroma: f32, palette_idx: usize) -> f32
   ```
   In the `HyAB` branch, destructure as `{ kl, kc, kchroma }` and add:
   ```rust
   let chroma_penalty = (pixel_chroma - self.actual_chroma[palette_idx]).abs();
   kl * dl + kc * (da * da + db * db).sqrt() + kchroma * chroma_penalty
   ```
   For `Euclidean`, ignore the extra parameters (just return `a.distance_squared(b)` as before).

5. **Palette::find_nearest()** (line ~329): Compute pixel chroma once before the loop:
   ```rust
   let pixel_chroma = (color.a * color.a + color.b * color.b).sqrt();
   ```
   Pass `pixel_chroma` and `i` to `self.distance(color, palette_color, pixel_chroma, i)` inside the loop.

6. **Update `make_6_color_palette()` test helper** (line ~610): Add `kchroma: 2.0` to the `DistanceMetric::HyAB` constructor.

7. **Update all existing test sites** that construct `DistanceMetric::HyAB { kl, kc }`: Add `kchroma` field. Locations:
   - `test_hyab_kc_forces_grey_to_achromatic` (line ~654): Use `kchroma: 2.0`
   - `with_distance_metric` doc example (line ~270): Add `kchroma: 2.0`

Now modify `blue_noise.rs`:

8. **find_second_nearest()** (line ~81): Change the signature to:
   ```rust
   fn find_second_nearest(color: Oklab, palette: &Palette, exclude: usize, pixel_chroma: f32) -> (usize, f32)
   ```
   Inside the loop (currently line ~95), change from `palette.distance(color, palette.actual_oklab(i))` to:
   ```rust
   let dist = palette.distance(color, palette.actual_oklab(i), pixel_chroma, i);
   ```
   This passes the palette index `i` as the 4th parameter so `distance()` can look up `actual_chroma[i]` for the chroma coupling penalty.

9. **BlueNoiseDither::dither()** (line ~130): After the existing `let oklab = Oklab::from(pixel);` at line ~130, compute pixel chroma once:
   ```rust
   let pixel_chroma = (oklab.a * oklab.a + oklab.b * oklab.b).sqrt();
   ```
   Then update the `find_second_nearest` call at line ~134 from:
   ```rust
   let (idx2, raw_dist2) = find_second_nearest(oklab, palette, idx1);
   ```
   to:
   ```rust
   let (idx2, raw_dist2) = find_second_nearest(oklab, palette, idx1, pixel_chroma);
   ```
   Note: `find_nearest()` computes its own `pixel_chroma` internally (step 5), so it does not need the value passed in. Only `find_second_nearest()` needs it because it is a free function outside `Palette`.

10. **Update blue_noise test** `test_grey_gradient_no_chromatic_noise` (line ~416): Change the `DistanceMetric::HyAB` construction to include `kchroma: 2.0`. Tighten the assertion from `achromatic_pct > 50.0` to `achromatic_pct == 100.0` (use exact check: assert all indices are 0 or 1). Update the comment to reflect that chroma coupling prevents ALL grey-to-chromatic mapping, not just "most."

Now modify `svg_to_png.rs`:

11. **build_eink_palette()** (line ~239): Change `DistanceMetric::HyAB { kl: 2.0, kc: 1.0 }` to `DistanceMetric::HyAB { kl: 2.0, kc: 1.0, kchroma: 2.0 }`.

**Important constraints:**
- Do NOT change the Euclidean branch behavior at all.
- Do NOT change error diffusion code or any other dithering algorithm.
- Do NOT modify `Oklab::distance_squared()` or `Oklab::hyab_distance()`.
- The chroma penalty MUST use `.abs()` -- a negative penalty would reduce total distance.
- Always populate `actual_chroma` regardless of distance metric (it is cheap and simplifies code).
  </action>
  <verify>
Run `cargo build -p eink-dither` and `cargo build` (main crate). Both must compile without errors or warnings. The compiler will enforce that all HyAB construction sites include kchroma and all distance() call sites pass the new parameters.
  </verify>
  <done>
All code compiles. The HyAB distance metric includes the kchroma field. The distance() method applies the chroma coupling penalty. find_nearest() computes pixel chroma once. find_second_nearest() accepts and passes pixel chroma. svg_to_png.rs uses kchroma: 2.0. No behavioral change to Euclidean mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add targeted tests and tighten existing assertions</name>
  <files>
    crates/eink-dither/src/palette/palette.rs
    CHANGES.md
  </files>
  <action>
Add three new tests to the `#[cfg(test)] mod tests` block in `palette.rs`, after the existing HyAB tests.

**Import note:** The test module at line ~389 uses `use super::*;` which transitively brings `Srgb`, `LinearRgb`, and `Oklab` into scope (from the parent module's `use crate::color::{LinearRgb, Oklab, Srgb};` at line 11). No additional imports are needed for the test code below.

1. **test_chroma_coupling_grey_gradient_bw_only**: Iterate all 256 grey values (0..=255), convert each to Oklab via sRGB -> LinearRgb -> Oklab, call `palette.find_nearest()` on the 6-color palette (from `make_6_color_palette()`), assert every result index is 0 (black) or 1 (white). This covers requirement TEST-01.

   ```rust
   #[test]
   fn test_chroma_coupling_grey_gradient_bw_only() {
       let palette = make_6_color_palette();
       for grey_val in 0..=255u8 {
           let grey = Oklab::from(LinearRgb::from(Srgb::from_u8(grey_val, grey_val, grey_val)));
           let (idx, _) = palette.find_nearest(grey);
           assert!(
               idx == 0 || idx == 1,
               "Grey {} mapped to index {} ({:?}), expected black or white",
               grey_val, idx, palette.official(idx).to_bytes()
           );
       }
   }
   ```

2. **test_chroma_coupling_chromatic_exact_match**: Test that pure red (255,0,0), green (0,255,0), blue (0,0,255), and yellow (255,255,0) each map to their corresponding palette index (2, 3, 4, 5). This covers requirement TEST-02.

   ```rust
   #[test]
   fn test_chroma_coupling_chromatic_exact_match() {
       let palette = make_6_color_palette();
       let test_cases = [
           (Srgb::from_u8(255, 0, 0), 2, "red"),
           (Srgb::from_u8(0, 255, 0), 3, "green"),
           (Srgb::from_u8(0, 0, 255), 4, "blue"),
           (Srgb::from_u8(255, 255, 0), 5, "yellow"),
       ];
       for (color, expected_idx, name) in test_cases {
           let oklab = Oklab::from(LinearRgb::from(color));
           let (idx, _) = palette.find_nearest(oklab);
           assert_eq!(idx, expected_idx,
               "Pure {} should map to index {}, got {}", name, expected_idx, idx);
       }
   }
   ```

3. **test_chroma_coupling_orange_maps_to_chromatic**: Test that orange (255,165,0) maps to a chromatic entry (index >= 2), not black or white. This covers requirement DIST-04.

   ```rust
   #[test]
   fn test_chroma_coupling_orange_maps_to_chromatic() {
       let palette = make_6_color_palette();
       let orange = Oklab::from(LinearRgb::from(Srgb::from_u8(255, 165, 0)));
       let (idx, _) = palette.find_nearest(orange);
       assert!(
           idx >= 2,
           "Orange should map to a chromatic entry (idx >= 2), got {}",
           idx
       );
   }
   ```

4. **Update `test_hyab_all_greys_map_to_valid_color`** (existing test): Update the comment to reflect that with chroma coupling, ALL greys now map to black or white. Change the assertion from just checking `idx < 6` and `dist >= 0.0` to also asserting `idx == 0 || idx == 1`. This tightens the test to match the new behavior.

5. **Update CHANGES.md**: In the Unreleased > Fixed section, update the existing color palette dithering bullet to mention chroma coupling:
   Change: "Uses HyAB perceptual distance metric (Abasi et al., 2020) which properly decouples lightness from chrominance."
   To: "Uses HyAB perceptual distance metric (Abasi et al., 2020) with chroma coupling penalty, which prevents achromatic pixels from matching chromatic palette entries."

Run the full test suite to confirm:
- All 3 new tests pass
- The tightened existing test passes
- The blue_noise grey gradient test now passes at 100% achromatic (was 41.9%)
- All other existing tests still pass (requirement TEST-05)
  </action>
  <verify>
Run `cargo test -p eink-dither 2>&1 | tail -20`. Expected: all tests pass, 0 failures. Specifically verify:
- `test_chroma_coupling_grey_gradient_bw_only ... ok`
- `test_chroma_coupling_chromatic_exact_match ... ok`
- `test_chroma_coupling_orange_maps_to_chromatic ... ok`
- `test_grey_gradient_no_chromatic_noise ... ok` (was FAILED before)
- `test_hyab_all_greys_map_to_valid_color ... ok`

Then run `make check` for full project validation (fmt + clippy + tests).
  </verify>
  <done>
All eink-dither tests pass (0 failures). The grey gradient test that was failing at 41.9% now passes. New tests verify: (1) all 256 greys map to B/W only, (2) pure chromatic colors match exact palette entries, (3) orange maps to chromatic not achromatic. CHANGES.md updated. `make check` passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo test -p eink-dither` -- all tests pass, 0 failures
2. `make check` -- fmt, clippy, and all tests pass
3. Grey gradient test produces 100% achromatic pixels (was 41.9%)
4. No regressions in existing domain tests
</verification>

<success_criteria>
- `cargo test -p eink-dither` reports 0 failures (previously 1 failure)
- Grey gradient (0-255) on BWRGBY palette: every grey maps to black or white
- Pure red/green/blue/yellow match their exact palette entries
- Orange maps to a chromatic entry (not black/white)
- `make check` passes clean (fmt + clippy + tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-distance-metric-fix/01-01-SUMMARY.md`
</output>
