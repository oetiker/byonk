---
phase: 02-auto-detection-and-edge-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/eink-dither/src/palette/palette.rs
  - src/rendering/svg_to_png.rs
  - crates/eink-dither/src/domain_tests.rs
autonomous: true

must_haves:
  truths:
    - "A chromatic palette (BWRGBY) auto-selects HyAB+chroma distance without caller configuration"
    - "An achromatic palette (BW, 4-grey) auto-selects Euclidean distance without caller configuration"
    - "Caller can still override auto-detected metric via with_distance_metric()"
    - "svg_to_png.rs no longer manually detects chromatic palettes -- the crate handles it"
    - "Edge-case colors (brown, dark red, dark blue, navy) map to correct chromatic palette entries"
    - "Pastel dithering output contains some chromatic pixels from error diffusion (chroma not lost)"
  artifacts:
    - path: "crates/eink-dither/src/palette/palette.rs"
      provides: "Auto-detection in Palette::new(), is_chromatic() method, CHROMA_DETECTION_THRESHOLD constant"
      contains: "CHROMA_DETECTION_THRESHOLD"
    - path: "src/rendering/svg_to_png.rs"
      provides: "Simplified build_eink_palette() without manual metric selection"
      min_lines: 5
    - path: "crates/eink-dither/src/domain_tests.rs"
      provides: "Pastel dithering and edge-case mapping regression tests"
      contains: "test_pastel_produces_chromatic_pixels"
  key_links:
    - from: "crates/eink-dither/src/palette/palette.rs"
      to: "Palette::new()"
      via: "auto-detection sets distance_metric based on actual_chroma max"
      pattern: "CHROMA_DETECTION_THRESHOLD"
    - from: "src/rendering/svg_to_png.rs"
      to: "crates/eink-dither/src/palette/palette.rs"
      via: "build_eink_palette no longer calls with_distance_metric"
      pattern: "EinkPalette::new"
---

<objective>
Add automatic distance metric selection to the eink-dither crate and validate edge-case color mapping.

Purpose: Eliminates manual caller burden -- chromatic palettes "just work" with HyAB+chroma, achromatic palettes get Euclidean. Also validates that pastels, browns, skin tones, and dark chromatic colors map correctly.

Output: Modified palette.rs with auto-detection, simplified svg_to_png.rs, new tests in domain_tests.rs and palette.rs.
</objective>

<execution_context>
@/Users/oetiker/.claude/get-shit-done/workflows/execute-plan.md
@/Users/oetiker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auto-detection-and-edge-cases/02-RESEARCH.md
@.planning/phases/01-core-distance-metric-fix/01-01-SUMMARY.md

Key source files:
@crates/eink-dither/src/palette/palette.rs
@src/rendering/svg_to_png.rs
@crates/eink-dither/src/domain_tests.rs
@crates/eink-dither/src/api/builder.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-detection to Palette::new() and simplify svg_to_png.rs</name>
  <files>
    crates/eink-dither/src/palette/palette.rs
    src/rendering/svg_to_png.rs
  </files>
  <action>
In `crates/eink-dither/src/palette/palette.rs`:

1. Add a constant above the `Palette` struct:
```rust
/// Chroma threshold for auto-detecting chromatic palettes.
/// Any palette entry with OKLab chroma above this is considered chromatic.
/// Pure greys have chroma=0.0 exactly. Intentional chromatic colors have
/// chroma > 0.05. Threshold 0.03 provides a clean separation with no
/// ambiguity even for near-grey device calibration noise.
const CHROMA_DETECTION_THRESHOLD: f32 = 0.03;
```

2. In `Palette::new()`, REPLACE the line:
```rust
distance_metric: DistanceMetric::default(),
```
with auto-detection logic that uses the already-computed `actual_chroma` vec:
```rust
distance_metric: if actual_chroma.iter().any(|&c| c > CHROMA_DETECTION_THRESHOLD) {
    DistanceMetric::HyAB {
        kl: 2.0,
        kc: 1.0,
        kchroma: 10.0,
    }
} else {
    DistanceMetric::Euclidean
},
```
This uses the `actual_chroma` Vec that Phase 1 already added. No new computation needed.

3. Add `is_chromatic()` method to the `impl Palette` block, near `is_euclidean()`:
```rust
/// Returns true if the palette was auto-detected as chromatic.
///
/// A palette is chromatic if any entry has OKLab chroma above the
/// detection threshold (0.03). Chromatic palettes default to
/// HyAB+chroma distance; achromatic palettes default to Euclidean.
/// Use [`with_distance_metric()`] to override the automatic selection.
pub fn is_chromatic(&self) -> bool {
    self.actual_chroma.iter().any(|&c| c > CHROMA_DETECTION_THRESHOLD)
}
```

4. Update the doc comment on `with_distance_metric()` to mention it overrides auto-detection:
```rust
/// Override the auto-detected distance metric for color matching.
///
/// By default, `Palette::new()` automatically selects the distance metric:
/// - Chromatic palettes (any entry with chroma > 0.03): HyAB+chroma
/// - Achromatic palettes (all greys): Euclidean
///
/// Use this method to override the automatic selection.
```

5. In the existing `make_6_color_palette()` test helper, REMOVE the `.with_distance_metric(...)` call since auto-detection now handles it. The function becomes:
```rust
fn make_6_color_palette() -> Palette {
    let colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    Palette::new(&colors, None).unwrap()
}
```
This validates that auto-detection picks HyAB+chroma for this palette (all existing tests using this helper implicitly verify auto-detection works).

6. Add auto-detection unit tests in the `mod tests` block at the bottom of palette.rs:
```rust
// Auto-detection tests

#[test]
fn test_auto_detect_bw_uses_euclidean() {
    let bw = Palette::new(
        &[Srgb::from_u8(0, 0, 0), Srgb::from_u8(255, 255, 255)],
        None,
    ).unwrap();
    assert!(bw.is_euclidean(), "BW palette should auto-select Euclidean");
    assert!(!bw.is_chromatic(), "BW palette should not be chromatic");
}

#[test]
fn test_auto_detect_4grey_uses_euclidean() {
    let greys = Palette::new(
        &[
            Srgb::from_u8(0, 0, 0),
            Srgb::from_u8(85, 85, 85),
            Srgb::from_u8(170, 170, 170),
            Srgb::from_u8(255, 255, 255),
        ],
        None,
    ).unwrap();
    assert!(greys.is_euclidean(), "4-grey palette should auto-select Euclidean");
    assert!(!greys.is_chromatic(), "4-grey palette should not be chromatic");
}

#[test]
fn test_auto_detect_bwrgby_uses_hyab() {
    let palette = make_6_color_palette();
    assert!(!palette.is_euclidean(), "BWRGBY should auto-select HyAB+chroma");
    assert!(palette.is_chromatic(), "BWRGBY should be chromatic");
}

#[test]
fn test_auto_detect_override_still_works() {
    // Auto-detected HyAB can be overridden to Euclidean
    let palette = Palette::new(
        &[
            Srgb::from_u8(0, 0, 0),
            Srgb::from_u8(255, 255, 255),
            Srgb::from_u8(255, 0, 0),
        ],
        None,
    ).unwrap()
    .with_distance_metric(DistanceMetric::Euclidean);
    assert!(palette.is_euclidean(), "Manual override should take precedence over auto-detection");
}

#[test]
fn test_auto_detect_near_grey_not_chromatic() {
    // Near-grey from device calibration noise should NOT trigger chromatic detection
    let palette = Palette::new(
        &[
            Srgb::from_u8(0, 0, 0),
            Srgb::from_u8(130, 128, 126),  // warm near-grey, chroma ~0.004
            Srgb::from_u8(255, 255, 255),
        ],
        None,
    ).unwrap();
    assert!(palette.is_euclidean(), "Near-grey palette should auto-select Euclidean");
}
```

In `src/rendering/svg_to_png.rs`:

7. In `build_eink_palette()`, REMOVE the manual chromatic detection block (lines 235-244 approximately). The function should become:
```rust
fn build_eink_palette(palette: &[(u8, u8, u8)]) -> Result<(EinkPalette, Vec<u8>), RenderError> {
    let mut unique_colors: Vec<EinkSrgb> = Vec::new();
    let mut index_map: Vec<u8> = Vec::new();

    for (orig_idx, &(r, g, b)) in palette.iter().enumerate() {
        let color = EinkSrgb::from_u8(r, g, b);
        let bytes = color.to_bytes();
        if !unique_colors.iter().any(|c| c.to_bytes() == bytes) {
            index_map.push(orig_idx as u8);
            unique_colors.push(color);
        }
    }

    let eink_palette = EinkPalette::new(&unique_colors, None)
        .map_err(|e| RenderError::Dither(format!("palette error: {e}")))?;

    // Distance metric is auto-detected by eink-dither based on palette content.
    // Chromatic palettes get HyAB+chroma; achromatic palettes get Euclidean.

    Ok((eink_palette, index_map))
}
```

8. Remove the unused `DistanceMetric` import from the top of svg_to_png.rs. The import line should change from:
```rust
use eink_dither::{
    DistanceMetric, EinkDitherer, Palette as EinkPalette, RenderingIntent, Srgb as EinkSrgb,
};
```
to:
```rust
use eink_dither::{
    EinkDitherer, Palette as EinkPalette, RenderingIntent, Srgb as EinkSrgb,
};
```

IMPORTANT: Do NOT change kchroma. It stays at 10.0. Do NOT add special pastel handling. Do NOT remove `with_distance_metric()` method.
  </action>
  <verify>
Run `cd /Users/oetiker/checkouts/byonk && cargo test -p eink-dither` -- all existing tests must pass (including the make_6_color_palette tests that now rely on auto-detection).

Run `cd /Users/oetiker/checkouts/byonk && cargo test --lib rendering::svg_to_png` -- svg_to_png tests must pass.

Run `cd /Users/oetiker/checkouts/byonk && cargo clippy -p eink-dither -- -D warnings` -- no warnings (confirms unused import removed).

Run `cd /Users/oetiker/checkouts/byonk && cargo clippy -- -D warnings` -- no warnings in main project (confirms DistanceMetric import removed from svg_to_png.rs).
  </verify>
  <done>
- Palette::new() auto-selects HyAB+chroma for BWRGBY and Euclidean for BW/grey palettes
- is_chromatic() method exists and returns correct values
- with_distance_metric() still works as override
- svg_to_png.rs no longer manually selects distance metric
- All 5 new auto-detection unit tests pass
- All existing tests pass unchanged (make_6_color_palette tests now implicitly verify auto-detection)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add edge-case tests for pastels, browns, skin tones, and dark chromatic colors</name>
  <files>
    crates/eink-dither/src/domain_tests.rs
    CHANGES.md
  </files>
  <action>
In `crates/eink-dither/src/domain_tests.rs`, add a new GAP section after GAP 6. Add imports for `Oklab` at the top of the `mod domain_tests` block (alongside existing imports):
```rust
use crate::color::Oklab;
```

Add new test section:

```rust
// ========================================================================
// GAP 7: Edge-case color mapping (TEST-03, TEST-04)
// ========================================================================

/// TEST-03: Pastel colors must not lose chroma information during dithering.
///
/// On a BWRGBY palette, pastels like light pink correctly map to WHITE in
/// per-pixel find_nearest (white is genuinely the closest palette color).
/// However, the error diffusion must propagate the chroma error to neighbors,
/// producing SOME chromatic pixels in the output. If the output is 100%
/// achromatic, chroma information is being lost.
///
/// If this breaks, it means: the chroma coupling penalty is too aggressive
/// and suppressing all chromatic signal even through error diffusion, OR
/// the preprocessing is desaturating pastels to pure grey.
#[test]
fn test_pastel_produces_chromatic_pixels_in_dither() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),       // 0: black
        Srgb::from_u8(255, 255, 255), // 1: white
        Srgb::from_u8(255, 0, 0),     // 2: red
        Srgb::from_u8(0, 255, 0),     // 3: green
        Srgb::from_u8(0, 0, 255),     // 4: blue
        Srgb::from_u8(255, 255, 0),   // 5: yellow
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    // Light pink (255,182,193) has chroma=0.086 -- clearly chromatic but
    // closer to white (L=1.0) than to red (L=0.628) in lightness.
    let light_pink = Srgb::from_u8(255, 182, 193);
    let image = vec![light_pink; 32 * 32];

    // Use Photo intent with neutral preprocessing to isolate dithering behavior
    let ditherer = EinkDitherer::new(palette, RenderingIntent::Photo)
        .saturation(1.0)
        .contrast(1.0);
    let result = ditherer.dither(&image, 32, 32);
    let indices = result.indices();

    // Must have SOME chromatic pixels from error diffusion
    let chromatic_count = indices.iter().filter(|&&idx| idx >= 2).count();
    assert!(
        chromatic_count > 0,
        "REGRESSION (TEST-03): Light pink (255,182,193) dithered to 100% achromatic. \
         Error diffusion should propagate chroma error to produce some chromatic pixels. \
         Chroma information is being lost."
    );

    // Must be PREDOMINANTLY white (light pink is much closer to white than red)
    let white_count = indices.iter().filter(|&&idx| idx == 1).count();
    assert!(
        white_count > chromatic_count,
        "REGRESSION (TEST-03): Light pink should be predominantly white, \
         got {} white vs {} chromatic. Lightness matching may be broken.",
        white_count, chromatic_count
    );
}

/// TEST-03 extended: Pale blue also preserves chroma through dithering.
#[test]
fn test_pale_blue_produces_chromatic_pixels_in_dither() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    let pale_blue = Srgb::from_u8(173, 216, 230);
    let image = vec![pale_blue; 32 * 32];

    let ditherer = EinkDitherer::new(palette, RenderingIntent::Photo)
        .saturation(1.0)
        .contrast(1.0);
    let result = ditherer.dither(&image, 32, 32);
    let indices = result.indices();

    let chromatic_count = indices.iter().filter(|&&idx| idx >= 2).count();
    assert!(
        chromatic_count > 0,
        "REGRESSION (TEST-03): Pale blue (173,216,230) dithered to 100% achromatic. \
         Error diffusion should propagate chroma error to produce some blue pixels."
    );
}

/// TEST-04: Brown maps to red (nearest warm chromatic) on BWRGBY.
///
/// If this breaks, it means: the HyAB distance metric is not correctly
/// balancing lightness vs chrominance for dark warm colors.
#[test]
fn test_brown_maps_to_red() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    let brown = Oklab::from(LinearRgb::from(Srgb::from_u8(139, 69, 19)));
    let (idx, _) = palette.find_nearest(brown);
    assert_eq!(
        idx, 2,
        "REGRESSION (TEST-04): Brown (139,69,19) should map to red (index 2), got index {}",
        idx
    );
}

/// TEST-04: Dark chromatic colors map to their chromatic palette entry, not black.
///
/// If this breaks, it means: the lightness weight (kl) is dominating the
/// distance metric, causing dark chromatic colors to collapse to black
/// instead of their correct chromatic match.
#[test]
fn test_dark_chromatic_maps_correctly() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    // Dark red should map to red, not black
    let dark_red = Oklab::from(LinearRgb::from(Srgb::from_u8(139, 0, 0)));
    let (idx, _) = palette.find_nearest(dark_red);
    assert_eq!(
        idx, 2,
        "REGRESSION (TEST-04): Dark red (139,0,0) should map to red (idx 2), got {}",
        idx
    );

    // Dark blue should map to blue, not black
    let dark_blue = Oklab::from(LinearRgb::from(Srgb::from_u8(0, 0, 139)));
    let (idx, _) = palette.find_nearest(dark_blue);
    assert_eq!(
        idx, 4,
        "REGRESSION (TEST-04): Dark blue (0,0,139) should map to blue (idx 4), got {}",
        idx
    );

    // Navy should map to blue, not black
    let navy = Oklab::from(LinearRgb::from(Srgb::from_u8(0, 0, 128)));
    let (idx, _) = palette.find_nearest(navy);
    assert_eq!(
        idx, 4,
        "REGRESSION (TEST-04): Navy (0,0,128) should map to blue (idx 4), got {}",
        idx
    );
}

/// TEST-04: Skin tone dithering produces warm chromatic pixels.
///
/// Medium skin tone (210,161,109) maps to white in find_nearest (similar
/// to pastels), but error diffusion should produce warm-toned output.
#[test]
fn test_skin_tone_dithering_produces_warm_pixels() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    let skin = Srgb::from_u8(210, 161, 109);
    let image = vec![skin; 32 * 32];

    let ditherer = EinkDitherer::new(palette, RenderingIntent::Photo)
        .saturation(1.0)
        .contrast(1.0);
    let result = ditherer.dither(&image, 32, 32);
    let indices = result.indices();

    // Should contain warm chromatic pixels (red=2 or yellow=5)
    let warm_count = indices.iter().filter(|&&idx| idx == 2 || idx == 5).count();
    assert!(
        warm_count > 0,
        "REGRESSION (TEST-04): Skin tone (210,161,109) dithered with no warm chromatic pixels. \
         Error diffusion should produce some red/yellow pixels."
    );

    // Should NOT contain blue or green (cold colors)
    let cold_count = indices.iter().filter(|&&idx| idx == 3 || idx == 4).count();
    let total = indices.len();
    assert!(
        cold_count < total / 20,
        "REGRESSION (TEST-04): Skin tone produced {} cold pixels (green/blue) out of {}. \
         Warm input should not produce significant cold output.",
        cold_count, total
    );
}

/// TEST-04: Dark green mapping (flagged for investigation).
///
/// Dark green (0,100,0) has chroma=0.148. Research found it might map to
/// yellow due to combined lightness and chroma distances. This test
/// documents the actual behavior.
#[test]
fn test_dark_green_maps_to_green_or_yellow() {
    let palette_colors = [
        Srgb::from_u8(0, 0, 0),
        Srgb::from_u8(255, 255, 255),
        Srgb::from_u8(255, 0, 0),
        Srgb::from_u8(0, 255, 0),
        Srgb::from_u8(0, 0, 255),
        Srgb::from_u8(255, 255, 0),
    ];
    let palette = Palette::new(&palette_colors, None).unwrap();

    let dark_green = Oklab::from(LinearRgb::from(Srgb::from_u8(0, 100, 0)));
    let (idx, _) = palette.find_nearest(dark_green);

    // Dark green should map to green (3) or possibly yellow (5) -- both are
    // acceptable chromatic mappings. It must NOT map to black (0) or white (1).
    assert!(
        idx == 3 || idx == 5,
        "REGRESSION (TEST-04): Dark green (0,100,0) should map to green (3) or yellow (5), \
         got index {} ({:?})",
        idx,
        palette_colors[idx].to_bytes()
    );
}
```

In `CHANGES.md`, add an entry in the Unreleased section:
- Add a bullet: "Auto-detect distance metric based on palette content -- chromatic palettes automatically use HyAB+chroma, achromatic palettes use Euclidean"

IMPORTANT:
- Do NOT lower kchroma from 10.0
- Do NOT add any special pastel-handling code paths
- Do NOT modify palette.rs beyond what Task 1 already did
- All tests reference `Palette::new()` WITHOUT `with_distance_metric()` to verify auto-detection
  </action>
  <verify>
Run `cd /Users/oetiker/checkouts/byonk && cargo test -p eink-dither -- domain_tests` -- all domain tests pass including new GAP 7 tests.

Run `cd /Users/oetiker/checkouts/byonk && make check` -- full project check passes (fmt, clippy, all tests).

Verify test count increased: `cd /Users/oetiker/checkouts/byonk && cargo test -p eink-dither 2>&1 | grep 'test result'` -- should show more tests than the previous 199.
  </verify>
  <done>
- 7 new edge-case tests pass: pastel light pink, pastel pale blue, brown, dark red/blue/navy, skin tone, dark green
- Pastels produce SOME chromatic pixels in dithered output (chroma not lost)
- Brown maps to red (idx 2)
- Dark red maps to red (idx 2), dark blue and navy map to blue (idx 4)
- Skin tones produce warm chromatic pixels (red/yellow), minimal cold pixels
- Dark green maps to green or yellow (both acceptable)
- Full make check passes
- CHANGES.md updated
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/oetiker/checkouts/byonk && make check` -- all fmt, clippy, and tests pass
2. `cd /Users/oetiker/checkouts/byonk && cargo test -p eink-dither 2>&1 | grep 'test result'` -- test count increased from 199
3. Verify auto-detection works: `cargo test -p eink-dither -- auto_detect` -- all 5 auto-detection tests pass
4. Verify edge cases work: `cargo test -p eink-dither -- domain_tests::domain_tests::test_brown domain_tests::domain_tests::test_dark domain_tests::domain_tests::test_pastel domain_tests::domain_tests::test_pale domain_tests::domain_tests::test_skin` -- all 7 new tests pass
5. Verify no regression: existing chroma coupling tests still pass with auto-detected metric
</verification>

<success_criteria>
- AUTO-01: `is_chromatic()` returns true for BWRGBY, false for BW and 4-grey palettes
- AUTO-02: BWRGBY auto-selects HyAB+chroma, BW/grey auto-selects Euclidean (verified by is_euclidean())
- AUTO-03: svg_to_png.rs no longer imports DistanceMetric or manually selects distance metric
- TEST-03: Pastel dithering tests (light pink, pale blue) produce SOME chromatic pixels
- TEST-04: Brown->red, dark red->red, dark blue->blue, navy->blue, dark green->green/yellow
- All previous 199 tests still pass
- make check passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-auto-detection-and-edge-cases/02-01-SUMMARY.md`
</output>
